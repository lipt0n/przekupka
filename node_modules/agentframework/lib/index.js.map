{"version":3,"file":"index.js","sources":["../../src/lib/Compiler/Internal/Utils.ts","../../src/lib/Reflection/Member.ts","../../src/lib/Reflection/Parameter.ts","../../src/lib/Reflection/Method.ts","../../src/lib/Reflection/Utils.ts","../../src/lib/Reflection/AgentFeatures.ts","../../src/lib/Reflection/Property.ts","../../src/lib/Reflection/PropertyFilters.ts","../../src/lib/Internal/Cache.ts","../../src/lib/Reflection/Type.ts","../../src/lib/Reflection/Reflector.ts","../../src/lib/Decorator/decorate.ts","../../src/lib/Compiler/Invocation/InitializerInvocation.ts","../../src/lib/Compiler/Invocation/InterceptorInvocation.ts","../../src/lib/Compiler/Invocation/AgentInvocation.ts","../../src/lib/Compiler/CreateAgentInvocation.ts","../../src/lib/Decorator/decorateAgent.ts","../../src/lib/Compiler/Internal/Parameter.ts","../../src/lib/Internal/Resolve.ts","../../src/lib/Compiler/Compiler.ts","../../src/lib/Compiler/Invocation/FieldInvocation.ts","../../src/lib/Compiler/Invocation/ParameterInvocation.ts","../../src/lib/Compiler/InitializerFactory.ts","../../src/lib/Compiler/InterceptorChainFactory.ts","../../src/lib/Compiler/Invocation/MethodInvocations.ts","../../src/lib/Compiler/InterceptorFunctionFactory.ts","../../src/lib/Compiler/AgentCompiler.ts","../../src/lib/Compiler/Invocation/ConstructInvocation.ts","../../src/lib/Compiler/InterceptorConstructorFactory.ts","../../src/lib/Compiler/Internal/Constants.ts","../../src/lib/Compiler/Initializer/LazyClassInitializer.ts","../../src/lib/Compiler/AgentAttribute.ts","../../src/lib/agent.ts","../../src/lib/Decorator/decorateParameter.ts","../../src/lib/Decorator/decorateClass.ts"],"sourcesContent":["/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IAttribute } from '../../Core/IAttribute';\n\nexport function CanDecorate(\n  attr: IAttribute,\n  target: Object | Function,\n  targetKey?: string | symbol,\n  descriptor?: PropertyDescriptor | number\n): boolean {\n  return attr.beforeDecorate(target, targetKey, descriptor);\n}\n\nexport function HasInterceptor(attribute: IAttribute): boolean {\n  return Reflect.has(attribute, 'interceptor');\n}\n\nexport function HasInitializer(attribute: IAttribute): boolean {\n  return Reflect.has(attribute, 'initializer');\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IAttribute, IInitializerAttribute, IInterceptorAttribute } from '../Core/IAttribute';\nimport { Constructor } from '../Compiler/Constructor';\nimport { HasInitializer, HasInterceptor } from '../Compiler/Internal/Utils';\n\n/**\n * Access and store attribute and metadata for reflection\n */\nexport abstract class Member<P> {\n  protected readonly parent: P;\n\n  private _attributes: Array<IAttribute> = [];\n  private _metadata: Map<string, any> = new Map<string, any>();\n  private _hasInterceptor: boolean = false;\n  private _hasInitializer: boolean = false;\n\n  protected constructor(parent: P) {\n    this.parent = parent;\n  }\n\n  /**\n   * Add an attribute\n   * @param {IAttribute} attribute\n   */\n  addAttribute(attribute: IAttribute): void {\n    this._attributes.push(attribute);\n    // if the attribute provide a getInterceptor, that means this property may need inject\n    // we don't call getInterceptor or getInitializer until user new() the agent class.\n    if (HasInterceptor(attribute)) {\n      this._hasInterceptor = true;\n    }\n    if (HasInitializer(attribute)) {\n      this._hasInitializer = true;\n    }\n  }\n\n  /**\n   * Return an array of attributes which is instance of giving type\n   * @returns {IAttribute[]}\n   */\n  getAttributes<U1 extends IAttribute>(type?: Constructor<U1>): U1[] {\n    if (type) {\n      return this._attributes.filter(a => a instanceof type) as Array<U1>;\n    } else {\n      return this._attributes.slice(0) as Array<U1>;\n    }\n  }\n\n  /**\n   * Return true if this type contains a giving attribute, otherwise false.\n   * @param type\n   * @returns {boolean}\n   */\n  hasAttribute<U2 extends IAttribute>(type?: Constructor<U2>): boolean {\n    if (type) {\n      return this._attributes.some(a => a instanceof type);\n    } else {\n      return !!this._attributes.length;\n    }\n  }\n\n  /**\n   * Return an array of all the attributes which provide getInterceptor method\n   * @returns {IInterceptorAttribute[]}\n   */\n  getInterceptors(): IInterceptorAttribute[] {\n    return this._attributes.filter(HasInterceptor) as IInterceptorAttribute[];\n  }\n\n  /**\n   * Return an array of all the attributes which provide getInitializer method\n   * @returns {IInitializerAttribute[]}\n   */\n  getInitializers(): IInitializerAttribute[] {\n    return this._attributes.filter(HasInitializer) as IInitializerAttribute[];\n  }\n\n  /**\n   * Return true if any of the attribute provide getInterceptor method\n   * @returns {boolean}\n   */\n  hasInterceptor(): boolean {\n    return this._hasInterceptor;\n  }\n\n  /**\n   * Return true if any of the attribute provide getInitializer method\n   *\n   * @returns {boolean}\n   */\n  hasInitializer(): boolean {\n    return this._hasInitializer;\n  }\n\n  /**\n   * Return true if have metadata\n   */\n  hasMetadata(): boolean {\n    return this._metadata.size > 0;\n  }\n\n  /**\n   * Read the metadata generated by tsc\n   *\n   * @param key\n   */\n  getMetadata(key: string): any | undefined {\n    return this._metadata.get(key);\n  }\n\n  /**\n   * Add the metadata generated by tsc\n   *\n   * @param {string} key\n   * @param value\n   */\n  addMetadata(key: string, value: any): void {\n    this._metadata.set(key, value);\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { Member } from './Member';\n\n/**\n * Parameter\n */\nexport class Parameter<P extends Member<any>> extends Member<P> {\n  constructor(parent: P, readonly index: number) {\n    super(parent);\n  }\n\n  get type(): any {\n    return this.getMetadata('design:type');\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { Member } from './Member';\nimport { Parameter } from './Parameter';\nimport { IsNumber } from './Utils';\n\n/**\n * Method\n */\nexport class Method<P> extends Member<P> {\n  private readonly _parameters: Array<Parameter<Method<P>>>;\n  private _cachedParameters: Array<Parameter<Method<P>>>;\n\n  constructor(parent: P, public maxParameters: number) {\n    super(parent);\n    this._parameters = new Array<Parameter<Method<P>>>();\n  }\n\n  parameter(index: number): Parameter<Method<P>> {\n    // throw error if out of bound\n    if (IsNumber(this.maxParameters) && index > this.maxParameters) {\n      throw new TypeError(`Parameter index out of boundary: ${index}. Max is ${this.maxParameters}`);\n    }\n    let parameter = this._parameters[index];\n    if (!parameter) {\n      parameter = new Parameter(this, index);\n      this._parameters[index] = parameter;\n    }\n    return parameter;\n  }\n\n  parameters(): Array<Parameter<Method<P>>> {\n    if (!this._cachedParameters) {\n      this._cachedParameters = this._parameters.filter(p => p.hasInitializer() || p.hasInterceptor());\n    }\n    return this._cachedParameters;\n  }\n\n  hasParameters(): boolean {\n    return this.parameters().length > 0;\n  }\n\n  get paramtypes(): Array<any> {\n    return this.getMetadata('design:paramtypes');\n  }\n\n  get returntype(): any {\n    return this.getMetadata('design:returntype');\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nexport function IsNumber(x: any): boolean {\n  return typeof x === 'number' && !isNaN(x);\n}\n\n// export class PrototypeIterator implements Iterator<Object> {\n//   constructor(private _current: Object) {}\n//   next() {\n//     const ret = { value: this._current, done: this._current != null };\n//     this._current = Object.getPrototypeOf(this._current);\n//     return ret;\n//   }\n// }\n\n// export class Prototypes implements Iterable<Object> {\n//   constructor(private _current: Object) {}\n//   [Symbol.iterator]() {\n//     return new PrototypeIterator(this._current);\n//   }\n// }\n\n// export function GetPrototypeIterator(prototype: Object): Iterable<Object> {\n//   return new Prototypes(prototype);\n// }\n\n// export function GetPrototypeArray(prototype: Object): Array<Object> {\n//   const list = [];\n//   while (prototype) {\n//     list.unshift(prototype);\n//     prototype = Object.getPrototypeOf(prototype);\n//   }\n//   return list;\n// }\n\n//\n//\n// export function IsEqual(x: any, y: any): boolean {\n//   // Compare primitives and functions.\n//   // Check if both arguments link to the same object.\n//   // Especially useful on the step where we compare prototypes\n//   if (x === y) {\n//     return true;\n//   }\n//\n//   if (typeof x === 'function' && typeof y === 'function') {\n//     return x.toString() === y.toString();\n//   }\n//\n//   if (x instanceof Date && y instanceof Date) {\n//     return x.getTime() === y.getTime();\n//   }\n//\n//   if (x instanceof RegExp && y instanceof RegExp) {\n//     return x.source === y.source;\n//   }\n//\n//   // remember that NaN === NaN returns false\n//   // and isNaN(undefined) returns true\n//   if (typeof x === 'number' && typeof y === 'number') {\n//     if (isNaN(x) && isNaN(y)) {\n//       return true;\n//     }\n//   }\n//\n//   if (typeof x !== typeof y) {\n//     if (!x === !y) {\n//       return true;\n//     }\n//   }\n//\n//   return x == y;\n// }\n//\n// /**\n//  * array = [\n//  *  [this.prototype]\n//  *  [this.prototype.prototype]\n//  *  [this.prototype.prototype.prototype]\n//  *  ...\n//  * ]\n//  */\n// export function GetPrototypeArray(typeOrInstance: any): Array<any> {\n//   const prototypes = [];\n//   let p = IsFunction(typeOrInstance) ? typeOrInstance.prototype : Object.getPrototypeOf(typeOrInstance);\n//   while (p) {\n//     prototypes.push(p);\n//     p = Object.getPrototypeOf(p);\n//   }\n//   return prototypes;\n// }\n//\n// /**\n//  * array = [\n//  *  ...\n//  *  [this.prototype.prototype.prototype]\n//  *  [this.prototype.prototype]\n//  *  [this.prototype]\n//  * ]\n//  */\n// export function GetPrototypeArrayReverse(typeOrInstance: any): Array<any> {\n//   const prototypes = [];\n//   let p = IsFunction(typeOrInstance) ? typeOrInstance.prototype : Object.getPrototypeOf(typeOrInstance);\n//   while (p) {\n//     prototypes.unshift(p);\n//     p = Object.getPrototypeOf(p);\n//   }\n//   return prototypes;\n// }\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nexport enum AgentFeatures {\n  /**\n   * has nothing\n   */\n  None = 0,\n\n  /**\n   * has metadata\n   */\n  Metadata = 1,\n\n  /**\n   * has initializer\n   */\n  Initializer = 2,\n\n  /**\n   * has interceptor\n   */\n  Interceptor = 4,\n\n  /**\n   * has initializer or interceptor\n   */\n  Altered = 6\n}\n\n// export function hasFeature(features: AgentFeatures, check: AgentFeatures): boolean {\n//   return (features & check) === check;\n// }\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { Method } from './Method';\nimport { AgentFeatures } from './AgentFeatures';\nimport { Member } from './Member';\nimport { Type } from './Type';\n\n/**\n * Property\n */\nexport class Property extends Member<Type> {\n  private _hasInitializers: boolean;\n  private _hasInterceptors: boolean;\n\n  constructor(parent: Type, private _key: PropertyKey, private _descriptor?: PropertyDescriptor) {\n    super(parent);\n  }\n\n  get value(): Method<Property> {\n    let maxFunctionParameters = 0;\n    const _descriptor = this._descriptor; // field don't have parameter\n    if (_descriptor && _descriptor.value && 'function' === typeof _descriptor.value) {\n      maxFunctionParameters = _descriptor.value.length;\n    }\n    const value = new Method(this, maxFunctionParameters);\n    Reflect.defineProperty(this, 'value', { value });\n    return value;\n  }\n\n  get setter(): Method<Property> {\n    const value = new Method(this, 1);\n    Reflect.defineProperty(this, 'setter', { value });\n    return value;\n  }\n\n  get getter(): Method<Property> {\n    const value = new Method(this, 0);\n    Reflect.defineProperty(this, 'getter', { value });\n    return value;\n  }\n\n  hasInitializers(): boolean {\n    if (this._hasInitializers == null) {\n      this._hasInitializers = this.hasInitializer() || this.setter.hasInitializer() || this.value.hasInitializer();\n    }\n    return this._hasInitializers;\n  }\n\n  hasInterceptors(): boolean {\n    if (this._hasInterceptors == null) {\n      this._hasInterceptors =\n        this.hasInterceptor() ||\n        this.getter.hasInterceptor() ||\n        this.value.hasInterceptor() ||\n        this.value.hasParameters();\n    }\n    return this._hasInterceptors;\n  }\n\n  hasFeatures(features: AgentFeatures): boolean {\n    if (this._hasInitializers && this._hasInterceptors) {\n      return features > 1;\n    }\n    switch (features) {\n      case AgentFeatures.Metadata:\n        return this.hasMetadata();\n      case AgentFeatures.Initializer:\n        return this.hasInitializers();\n      case AgentFeatures.Interceptor:\n        return this.hasInterceptors();\n      case AgentFeatures.Altered:\n        return this.hasInitializers() || this.hasInterceptors();\n      default:\n        return false;\n    }\n  }\n\n  get type(): any {\n    return this.getMetadata('design:type');\n  }\n\n  get paramtypes(): Array<any> {\n    return this.getMetadata('design:paramtypes');\n  }\n\n  get returntype(): any {\n    return this.getMetadata('design:returntype');\n  }\n\n  get targetKey(): PropertyKey {\n    return this._key;\n  }\n\n  get descriptor(): PropertyDescriptor | undefined {\n    return this._descriptor;\n  }\n\n  /**\n   * Add the metadata generated by tsc\n   * @param {string} key\n   * @param value\n   */\n  addMetadata(key: string, value: any): void {\n    super.addMetadata(key, value);\n\n    // apply method parameter type into parameter metadata\n    if (this._descriptor) {\n      if (this._descriptor.value) {\n        // this is a method\n        if (key === 'design:paramtypes' && value && value.length) {\n          this.value.addMetadata('design:paramtypes', value);\n          const types = value as Array<any>;\n          for (let idx = types.length - 1; idx >= 0; idx--) {\n            this.value.parameter(idx).addMetadata('design:type', types[idx]);\n          }\n        } else if (key === 'design:returntype') {\n          this.value.addMetadata('design:returntype', value);\n        }\n      }\n\n      if (this._descriptor.get) {\n        if (key === 'design:type') {\n          this.getter.addMetadata('design:returntype', value);\n        }\n      }\n\n      if (this._descriptor.set) {\n        if (key === 'design:paramtypes' && value && value.length) {\n          this.setter.addMetadata('design:paramtypes', value);\n          const types = value as Array<any>;\n          for (let idx = types.length - 1; idx >= 0; idx--) {\n            this.setter.parameter(idx).addMetadata('design:type', types[idx]);\n          }\n        }\n      }\n    } else {\n      // this is field\n      this.value.addMetadata(key, value);\n    }\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { Property } from './Property';\nimport { Constructor } from '../Compiler/Constructor';\nimport { AgentFeatures } from './AgentFeatures';\nimport { IAttribute } from '../Core/IAttribute';\n\n/**\n * Represents a callback function that is used to filter a list of behavior represented in a map of Behavior objects.\n */\nexport interface PropertyFilter {\n  /**\n   * @param {Property} value The Behavior object to which the filter is applied.\n   * @param filterCriteria An arbitrary object used to filter the list.\n   * @returns {boolean} `true` to include the behavior in the filtered list; otherwise false.\n   */\n  (value: Property, filterCriteria?: any): boolean;\n}\n\nexport class PropertyFilters {\n  static FilterAttribute<T extends IAttribute>(property: Property, filterCriteria?: Constructor<T>): boolean {\n    return property.hasAttribute(filterCriteria);\n  }\n\n  static FilterFeatures(property: Property, filterCriteria?: AgentFeatures): boolean {\n    if (filterCriteria == null) {\n      throw new Error('Missing AgentFeatures to filter');\n    }\n    return property.hasFeatures(filterCriteria);\n  }\n\n  // static FilterName(value: Property, filterCriteria?: any): boolean {\n  //   return true;\n  // }\n  //\n  // static FilterNameIgnoreCase(value: Property, filterCriteria?: any): boolean {\n  //   return true;\n  // }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { Constructor } from '../Compiler/Constructor';\n\n/* tslint:disable */\nconst GetWeakMap = new Function('k', 'return k=Symbol.for(k),this[k]||(this[k]=new WeakMap())');\nexport const Agents: WeakMap<any, any> = GetWeakMap('AgentFramework.Agents');\nexport const Types: WeakMap<any, any> = GetWeakMap('AgentFramework.Types');\n/* tslint:enable */\n\nexport function IsAgent(agent: Function): boolean {\n  return Agents.has(agent);\n}\n\nexport function GetType<T>(agent: Function): Constructor<T> | undefined {\n  return Agents.get(agent);\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { Constructor } from '../Compiler/Constructor';\nimport { Method } from './Method';\nimport { Property } from './Property';\nimport { PropertyFilter, PropertyFilters } from './PropertyFilters';\nimport { AgentFeatures } from './AgentFeatures';\nimport { Types } from '../Internal/Cache';\n\n/**\n * Reflection information for user class\n *\n * A class is a Function. So Class extends from Method\n */\nexport class Type extends Method<null> {\n  private readonly _prototype: object;\n  private readonly _properties: Map<PropertyKey, Property>;\n  private _prototypes: Array<Type>;\n\n  constructor(prototype: Object) {\n    super(null, prototype.constructor.length);\n    this._prototype = prototype;\n    this._properties = new Map<PropertyKey, Property>();\n  }\n\n  static of(prototype: Object): Type {\n    let found = Types.get(prototype);\n    if (!found) {\n      found = new Type(prototype);\n      Types.set(prototype, found);\n    }\n    return found;\n  }\n\n  /**\n   * Return the constructor of reflecting class\n   */\n  get class(): Constructor<any> {\n    return this._prototype.constructor as Constructor<any>;\n  }\n\n  /**\n   * Return the prototype of reflecting class\n   */\n  get prototype(): object {\n    return this._prototype;\n  }\n\n  /**\n   * Return prototype array for current type - deep first [base of base, base, this]\n   */\n  types(): Array<Type> {\n    if (!this._prototypes) {\n      this._prototypes = [];\n      let p = this._prototype;\n      while (p) {\n        this._prototypes.unshift(Type.of(p));\n        p = Object.getPrototypeOf(p);\n      }\n    }\n    return this._prototypes;\n  }\n\n  /**\n   * Add the metadata\n   */\n  addMetadata(key: string, value: any) {\n    // for class\n    super.addMetadata(key, value);\n    // apply class method parameter type into parameter metadata\n    if (key === 'design:paramtypes' && value && value.length) {\n      const types = value as Array<any>;\n      for (let idx = types.length - 1; idx >= 0; idx--) {\n        this.parameter(idx).addMetadata('design:type', types[idx]);\n      }\n    }\n  }\n\n  /**\n   * Return property info for specified property key\n   *\n   * @param {string | Symbol | number} key\n   * @param {PropertyDescriptor} descriptor\n   * @returns {Property}\n   */\n  property(key: PropertyKey, descriptor?: PropertyDescriptor): Property {\n    if (!this._properties.has(key)) {\n      descriptor = descriptor || Object.getOwnPropertyDescriptor(this._prototype, key);\n      this._properties.set(key, new Property(this, key, descriptor));\n    }\n    return this._properties.get(key)!;\n  }\n\n  /**\n   * Return all properties\n   *\n   * @returns {IterableIterator<Property>}\n   */\n  properties(): IterableIterator<Property> {\n    return this._properties.values();\n  }\n\n  /**\n   * Return true if contains the giving agent feature\n   */\n  hasFeatures(feature: AgentFeatures): boolean {\n    for (const type of this.types()) {\n      for (const property of type._properties.values()) {\n        if (PropertyFilters.FilterFeatures(property, feature)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns a filtered array of Property objects of this prototype.\n   *\n   * @param {PropertyFilter} filter\n   * @param filterCriteria\n   * @returns {Property[]}\n   */\n  findOwnProperties(filter: PropertyFilter, filterCriteria?: any): Map<PropertyKey, Property> {\n    const properties = new Map<PropertyKey, Property>();\n    for (const [key, property] of this._properties.entries()) {\n      if (filter(property, filterCriteria)) {\n        properties.set(key, property);\n      }\n    }\n    return properties;\n  }\n\n  /**\n   * Returns a filtered array of Property objects for all prototype in prototype chain.\n   *\n   * @param {PropertyFilter} filter\n   * @param filterCriteria\n   * @returns {Property[]}\n   */\n  findProperties(filter: PropertyFilter, filterCriteria?: any): Array<[Type, Map<PropertyKey, Property>]> {\n    const layers: Array<[Type, Map<PropertyKey, Property>]> = [];\n    for (const type of this.types()) {\n      const properties = type.findOwnProperties(filter, filterCriteria);\n      layers.push([type, properties]);\n    }\n    return layers;\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { Type } from './Type';\nimport { Agents } from '../Internal/Cache';\n\n/**\n * Reflector is the interface to access type data from class or class instance or class prototype\n */\nexport function Reflector(target: Function | Object): Type {\n  if (new.target) {\n    // NOTE: in AgentFramework 1.0, the reflection data can only set on Class.\n    // At present, we didn't found any use case to access reflection data on instance.\n    // We will added the support if got enough requirements.\n    throw new SyntaxError(`Not allow calling new Reflector`);\n  }\n\n  let ctor;\n  if ('function' === typeof target) {\n    ctor = target;\n  } else if ('object' === typeof target) {\n    // if a object hasOwnPropertyDescriptor('constructor') then this object is a prototype\n    const constructor = Object.getOwnPropertyDescriptor(target, 'constructor');\n    if (constructor && 'function' === typeof constructor.value) {\n      return Type.of(target);\n    } else {\n      throw new Error('AgentFramework 1.x do not support access metadata on instance');\n    }\n  } else {\n    // number, boolean\n    throw new TypeError(`Reflection target type is not supported`);\n  }\n\n  let proto;\n  // make sure get the prototype of origin type\n  if (Agents.has(ctor)) {\n    proto = Agents.get(ctor)!.prototype;\n  } else {\n    proto = ctor.prototype;\n  }\n\n  return Type.of(proto);\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IAttribute } from '../Core/IAttribute';\nimport { Reflector } from '../Reflection/Reflector';\nimport { CanDecorate } from '../Compiler/Internal/Utils';\n\nexport enum Target {\n  Constructor = 1,\n  ConstructorParameter = 2,\n  Field = 4,\n  Method = 8,\n  MethodParameter = 16,\n  Getter = 32,\n  Setter = 64\n}\n\n/**\n * This is universal decorator for all supported target\n */\nexport interface UniversalDecorator {\n  (target: Function | Object, targetKey?: string | symbol, descriptor?: number | PropertyDescriptor): any;\n}\n\n/**\n * Decorate attribute to the target\n */\nexport function decorate(attribute: IAttribute, allows: Target): UniversalDecorator {\n  return (target: Object | Function, targetKey?: string | symbol, descriptor?: PropertyDescriptor | number): any => {\n    let descriptorType = typeof descriptor;\n\n    if (targetKey == null) {\n      if (descriptorType === 'number') {\n        // this is constructor parameter\n        if (Target.ConstructorParameter !== (allows & Target.ConstructorParameter)) {\n          throw new TypeError(`${attribute.constructor.name} is not allow decorate on constructor parameters`);\n        }\n      } else {\n        // this is constructor\n        if (Target.Constructor !== (allows & Target.Constructor)) {\n          throw new TypeError(`${attribute.constructor.name} is not allow decorate on class`);\n        }\n      }\n    } else {\n      if (descriptorType === 'number') {\n        // this is constructor parameter\n        if (Target.MethodParameter !== (allows & Target.MethodParameter)) {\n          throw new TypeError(`${attribute.constructor.name} is not allow decorate on method parameters`);\n        }\n      } else if (descriptor) {\n        if (descriptor['value']) {\n          if (typeof descriptor['value'] === 'function') {\n            // this is method\n            if (Target.Method !== (allows & Target.Method)) {\n              throw new TypeError(`${attribute.constructor.name} is not allow decorate on method`);\n            }\n          } else {\n            // this is field\n            if (Target.Field !== (allows & Target.Field)) {\n              throw new TypeError(`${attribute.constructor.name} is not allow decorate on field`);\n            }\n          }\n        }\n        if (descriptor['get']) {\n          // this is constructor parameter\n          if (Target.Getter !== (allows & Target.Getter)) {\n            throw new TypeError(`${attribute.constructor.name} is not allow decorate on getter`);\n          }\n        }\n        if (descriptor['set']) {\n          // this is constructor parameter\n          if (Target.Setter !== (allows & Target.Setter)) {\n            throw new TypeError(`${attribute.constructor.name} is not allow decorate on setter`);\n          }\n        }\n      } else {\n        // this is constructor\n        if (Target.Field !== (allows & Target.Field)) {\n          throw new TypeError(`${attribute.constructor.name} is not allow decorate on field`);\n        }\n      }\n    }\n\n    if (CanDecorate(attribute, target, targetKey)) {\n      if (targetKey == null) {\n        if (descriptorType === 'number') {\n          if (CanDecorate(attribute, target, targetKey)) {\n            Reflector(target)\n              .parameter(descriptor as number)\n              .addAttribute(attribute);\n          }\n        } else {\n          Reflector(target).addAttribute(attribute);\n        }\n      } else {\n        if (descriptorType === 'number') {\n          Reflector(target)\n            .property(targetKey)\n            .value.parameter(descriptor as number)\n            .addAttribute(attribute);\n        } else if (descriptor) {\n          Reflector(target)\n            .property(targetKey, descriptor as PropertyDescriptor)\n            .value.addAttribute(attribute);\n        } else {\n          Reflector(target)\n            .property(targetKey)\n            .value.addAttribute(attribute);\n        }\n      }\n    }\n  };\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInvocation } from '../../Core/IInvocation';\nimport { IInitializer } from '../../Core/IInitializer';\n\n/**\n * @ignore\n * @hidden\n */\nexport class InitializerInvocation implements IInvocation {\n  constructor(private _invocation: IInvocation, private _initializer: IInitializer) { }\n\n  get design(): any {\n    return this._invocation.design;\n  }\n\n  get target(): Function {\n    return this._invocation.target;\n  }\n\n  get agent(): object | undefined {\n    return this._invocation.agent;\n  }\n\n  invoke(parameters: ArrayLike<any>): any {\n    return this._initializer.initialize(this._invocation, parameters);\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInvocation } from '../../Core/IInvocation';\nimport { IInterceptor } from '../../Core/IInterceptor';\n\n/**\n * @ignore\n * @hidden\n */\nexport class InterceptorInvocation implements IInvocation {\n  constructor(private _invocation: IInvocation, private _interceptor: IInterceptor) { }\n\n  get design(): any {\n    return this._invocation.design;\n  }\n\n  get target(): Function {\n    return this._invocation.target;\n  }\n\n  get agent(): object | undefined {\n    return this._invocation.agent;\n  }\n\n  invoke(parameters: ArrayLike<any>): any {\n    return this._interceptor.intercept(this._invocation, parameters);\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInvocation } from '../../Core/IInvocation';\nimport { Type } from '../../Reflection/Type';\nimport { Reflector } from '../../Reflection/Reflector';\n\n/**\n * @ignore\n * @hidden\n */\nexport class AgentInvocation implements IInvocation {\n  constructor(private readonly _target: Function) { }\n\n  get design(): Type {\n    return Reflector(this._target);\n  }\n\n  get target(): Function {\n    return this._target;\n  }\n\n  get agent(): object | undefined {\n    return undefined;\n  }\n\n  invoke([target, code, agent]: [Function, string, Object]): any {\n    if (target === this.target) {\n      return target;\n    }\n    // cheating v8\n    const args = [target, 'Reflect', `return ${code}`];\n    return Reflect.construct(Function, args)(this.target, agent);\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { InitializerInvocation } from './Invocation/InitializerInvocation';\nimport { InterceptorInvocation } from './Invocation/InterceptorInvocation';\nimport { AgentInvocation } from './Invocation/AgentInvocation';\nimport { IInvocation } from '../Core/IInvocation';\nimport { Agents } from '../Internal/Cache';\nimport { IAttribute } from '../Core/IAttribute';\n\n/**\n * Build Agent using AgentAttribute\n */\nexport function CreateAgentInvocation<C extends Function>(target: C, attribute: IAttribute): C {\n  if (Agents.has(target)) {\n    return target;\n  }\n\n  // chain the pipeline\n  // custom interceptors -> agent interceptor -> agent initializer -> agent invocation\n  let invocation: IInvocation = new AgentInvocation(target);\n\n  // add agent initializer into pipeline\n  const initializer = attribute.initializer;\n  if (initializer && 'function' === typeof initializer.initialize) {\n    invocation = new InitializerInvocation(invocation, initializer);\n  }\n  // add agent interceptor into pipeline\n  const interceptor = attribute.interceptor;\n  if (interceptor && 'function' === typeof interceptor.intercept) {\n    invocation = new InterceptorInvocation(invocation, interceptor);\n  }\n\n  const newTarget = invocation.invoke<C>(arguments);\n  if (newTarget !== target) {\n    Agents.set(newTarget, target);\n  }\n  return newTarget;\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IAttribute } from '../Core/IAttribute';\nimport { CanDecorate } from '../Compiler/Internal/Utils';\nimport { CreateAgentInvocation } from '../Compiler/CreateAgentInvocation';\nimport { AgentAttribute } from '../Compiler/AgentAttribute';\nimport { Reflector } from '../Reflection/Reflector';\n\n/**\n * Decorate an agent with customized initializer, interceptors and attributes\n *\n * @param {AgentAttribute} options\n * @param {IAttribute[]} attributes\n * @returns {ClassDecorator}\n */\nexport function decorateAgent(options: AgentAttribute, attributes?: IAttribute[]): ClassDecorator {\n  // upgrade target constructor to agent\n  // this method will be called\n  return <TFunction extends Function>(target: TFunction): TFunction | void => {\n    // apply extra attributes\n    if (attributes && attributes.length) {\n      const type = Reflector(target);\n      for (const attribute of attributes) {\n        if (CanDecorate(attribute, target)) {\n          type.addAttribute(attribute);\n        }\n      }\n    }\n\n    // the attributes to initialize agent constructor\n    // current only support only one initializer, one interceptor\n    if (CanDecorate(options, target)) {\n      // run this pipeline to generate a new constructor for this giving type\n      return CreateAgentInvocation(target, options);\n    }\n    return target;\n  };\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nexport const parameter = new WeakMap<object, ArrayLike<any>>();\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { Constructor } from '../Compiler/Constructor';\nimport { Types } from './Cache';\n\nexport function Resolve<T>(type: Constructor<T>, params?: ArrayLike<any>): T {\n  let found = Types.get(type);\n  if (found === undefined) {\n    found = Reflect.construct(type, params || []) as T;\n    Types.set(type, found);\n  }\n  return found;\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInvocation } from '../Core/IInvocation';\nimport { Arguments } from './Arguments';\n\n/**\n * Generate custom class\n */\nexport class Compiler {\n  private readonly generated: Function;\n\n  constructor(private target: Function) {\n    this.generated = this.target;\n  }\n\n  defineFields(fields: Map<PropertyKey, [IInvocation, IInvocation]>, params: Arguments) {\n    // invoke all initializers to generate default value bag\n    if (fields && fields.size) {\n      for (const [key, [origin, initializer]] of fields) {\n        Object.defineProperty(this.generated.prototype, key, {\n          get: function () {\n            Reflect.set(origin, 'agent', this);\n            const value = initializer.invoke(params());\n            Reflect.defineProperty(this, key, {\n              value,\n              configurable: true,\n              enumerable: true,\n              writable: true\n            });\n            return value;\n          },\n          set: function (value: any) {\n            Reflect.defineProperty(this, key, {\n              value,\n              configurable: true,\n              enumerable: true,\n              writable: true\n            });\n          },\n          configurable: true,\n          enumerable: true\n        });\n      }\n    }\n  }\n\n  defineProperties(properties: Map<PropertyKey, PropertyDescriptor>) {\n    if (properties && properties.size) {\n      for (const [key, descriptor] of properties) {\n        Object.defineProperty(this.generated.prototype, key, descriptor);\n      }\n    }\n  }\n\n  compile(): Function {\n    return this.generated;\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInvocation } from '../../Core/IInvocation';\nimport { Property } from '../../Reflection/Property';\n\n/**\n * @ignore\n * @hidden\n */\nexport class FieldInvocation implements IInvocation {\n  constructor(\n    private _target: Function,\n    _propertyKey: PropertyKey,\n    private _design: Property,\n    private _newAgent?: object\n  ) { }\n\n  get design(): Property {\n    return this._design;\n  }\n\n  get target(): Function {\n    return this._target;\n  }\n\n  get agent(): object | undefined {\n    return this._newAgent;\n  }\n\n  set agent(value: object | undefined) {\n    this._newAgent = value;\n  }\n\n  invoke(parameters: ArrayLike<any>): any {\n    // how to know the value of a field before you create that class\n    // return the value from prototype is a good choose? NO, it may cause infinite loops\n    return undefined;\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInvocation } from '../../Core/IInvocation';\nimport { Parameter } from '../../Reflection/Parameter';\n\n/**\n * @ignore\n * @hidden\n */\nexport class ParameterInvocation implements IInvocation {\n  constructor(private _target: Function, private _design: Parameter<any>, private _newAgent?: object) { }\n\n  get design(): Parameter<any> {\n    return this._design;\n  }\n\n  get target(): Function {\n    return this._target;\n  }\n\n  get agent(): object | undefined {\n    return this._newAgent;\n  }\n\n  set agent(value: object | undefined) {\n    this._newAgent = value;\n  }\n\n  invoke(parameters: ArrayLike<any>): any {\n    // parameters[0] = value of index\n    // parameters[1] = index of this parameter\n    // parameters[2] = all parameters\n    return parameters[0];\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInvocation } from '../Core/IInvocation';\nimport { IAttribute } from '../Core/IAttribute';\nimport { Parameter } from '../Reflection/Parameter';\nimport { InitializerInvocation } from './Invocation/InitializerInvocation';\nimport { FieldInvocation } from './Invocation/FieldInvocation';\nimport { ParameterInvocation } from './Invocation/ParameterInvocation';\nimport { Property } from '../Reflection/Property';\n\n/**\n * @ignore\n * @hidden\n */\nexport class InitializerFactory {\n\n  static createFieldInitializer(target: Function, propertyKey: PropertyKey, design: Property): IInvocation {\n    return new FieldInvocation(target, propertyKey, design);\n  }\n\n  static createParameterInitializer(target: Function, design: Parameter<any>): IInvocation {\n    return new ParameterInvocation(target, design);\n  }\n\n  static chainInitializerAttributes(origin: IInvocation, attributes: Array<IAttribute>): IInvocation {\n    // make invocation chain of interceptors\n    for (const attribute of attributes) {\n      const initializer = attribute.initializer;\n      if (initializer && 'function' === typeof initializer.initialize) {\n        origin = new InitializerInvocation(origin, initializer);\n      }\n    }\n    return origin;\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { InterceptorInvocation } from './Invocation/InterceptorInvocation';\nimport { IInvocation } from '../Core/IInvocation';\nimport { IAttribute } from '../Core/IAttribute';\n\n/**\n * @ignore\n * @hidden\n */\nexport class InterceptorChainFactory {\n  /**\n   * @ignore\n   * @hidden\n   */\n  static chainInterceptorAttributes(origin: IInvocation, attributes: Array<IAttribute>): IInvocation {\n    // make invocation chain of interceptors\n    for (const attribute of attributes) {\n      const interceptor = attribute.interceptor;\n      if (interceptor && 'function' === typeof interceptor.intercept) {\n        origin = new InterceptorInvocation(origin, interceptor);\n      }\n    }\n    return origin;\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInvocation } from '../../Core/IInvocation';\nimport { Method } from '../../Reflection/Method';\nimport { Property } from '../../Reflection/Property';\n\nexport class DirectMethodInvocation implements IInvocation {\n  constructor(\n    readonly _target: Function,\n    readonly method: Function,\n    readonly _design: Method<Property>,\n    private _newAgent?: object\n  ) { }\n\n  get design(): Method<Property> {\n    return this._design;\n  }\n\n  get target(): Function {\n    return this._target;\n  }\n\n  get agent(): object | undefined {\n    return this._newAgent;\n  }\n\n  set agent(value: object | undefined) {\n    this._newAgent = value;\n  }\n\n  invoke(parameters: ArrayLike<any>): any {\n    return Reflect.apply(this.method, this._newAgent, parameters);\n  }\n}\n\nexport class InterceptedMethodInvocation implements IInvocation {\n  constructor(\n    readonly _target: Function,\n    readonly method: Function,\n    readonly _design: Method<Property>,\n    readonly params: Map<number, [IInvocation, IInvocation]>,\n    private _newAgent?: object\n  ) { }\n\n  get design(): Method<Property> {\n    return this._design;\n  }\n\n  get target(): Function {\n    return this._target;\n  }\n\n  get agent(): object | undefined {\n    return this._newAgent;\n  }\n\n  set agent(value: object | undefined) {\n    this._newAgent = value;\n    for (const [, [origin]] of this.params.entries()) {\n      Reflect.set(origin, 'agent', value);\n    }\n  }\n\n  invoke(parameters: ArrayLike<any>) {\n    const params = Array.prototype.slice.call(parameters, 0);\n    for (const [idx, [, interceptor]] of this.params.entries()) {\n      params[idx] = interceptor.invoke([parameters[idx], idx, parameters]);\n    }\n    return Reflect.apply(this.method, this._newAgent, params);\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { DirectMethodInvocation, InterceptedMethodInvocation } from './Invocation/MethodInvocations';\nimport { IInvocation } from '../Core/IInvocation';\nimport { IAttribute } from '../Core/IAttribute';\nimport { Method } from '../Reflection/Method';\nimport { Property } from '../Reflection/Property';\nimport { InterceptorChainFactory } from './InterceptorChainFactory';\n\n/**\n * @ignore\n * @hidden\n */\nexport class InterceptorFunctionFactory {\n  static createFunction(\n    attributes: Array<IAttribute>,\n    target: Function,\n    method: Function,\n    design: Method<Property>,\n    params?: Map<number, [IInvocation, IInvocation]>\n  ): Function {\n    let origin: IInvocation;\n    let factory: Function;\n    if (params && params.size) {\n      origin = new InterceptedMethodInvocation(target, method, design, params);\n      factory = new Function('c', 'o', `return function ${method.name}$(){return o.agent=this,c.invoke(arguments)}`);\n    } else {\n      origin = new DirectMethodInvocation(target, method, design);\n      factory = new Function('c', 'o', `return function(){return o.agent=this,c.invoke(arguments)}`);\n    }\n    const chain = InterceptorChainFactory.chainInterceptorAttributes(origin, attributes);\n    if (chain instanceof DirectMethodInvocation) {\n      // do nothing\n      return method;\n    } else {\n      return factory(chain, origin);\n    }\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\n// utilize code gen\nimport { ICompiler } from './ICompiler';\nimport { Compiler } from './Compiler';\nimport { InitializerFactory } from './InitializerFactory';\nimport { InitializerInvocation } from './Invocation/InitializerInvocation';\nimport { InterceptorInvocation } from './Invocation/InterceptorInvocation';\nimport { Arguments } from './Arguments';\nimport { IInvocation } from '../Core/IInvocation';\nimport { AgentFeatures } from '../Reflection/AgentFeatures';\nimport { Reflector } from '../Reflection/Reflector';\nimport { PropertyFilters } from '../Reflection/PropertyFilters';\nimport { Method } from '../Reflection/Method';\nimport { InterceptorChainFactory } from './InterceptorChainFactory';\nimport { InterceptorFunctionFactory } from './InterceptorFunctionFactory';\nimport { IsAgent } from '../Internal/Cache';\n\nexport class AgentCompiler implements ICompiler {\n  compile(target: Function, params: Arguments): Function {\n    const names = new Set<PropertyKey>();\n    let initializers: any;\n    let interceptors: any;\n\n    // field property initializer\n    initializers = this.makePropertyInitializers(target, names);\n\n    // do Interceptor\n    interceptors = this.makePropertyInterceptors(target, names);\n\n    let compiled;\n\n    if (initializers || interceptors) {\n      const compiler = new Compiler(target);\n      compiler.defineFields(initializers, params);\n      compiler.defineProperties(interceptors);\n      compiled = compiler.compile();\n    } else {\n      //\n      compiled = target;\n    }\n\n    return compiled;\n  }\n\n  compileParameters(target: Function, method: Method<any>): Map<number, [IInvocation, IInvocation]> {\n    const parameters = method.parameters();\n    const parameterInitializers = new Map<number, [IInvocation, IInvocation]>();\n\n    for (const parameter of parameters) {\n      // get all initializer\n      let initializerAttributes = parameter.getInitializers();\n\n      // apply initializers\n      const origin = InitializerFactory.createParameterInitializer(target, parameter);\n\n      const initialized = InitializerFactory.chainInitializerAttributes(origin, initializerAttributes);\n\n      // get all interceptor\n      let interceptorAttributes = parameter.getInterceptors();\n\n      // apply interceptors\n      const intercepted = InterceptorChainFactory.chainInterceptorAttributes(initialized, interceptorAttributes);\n\n      // getAvailableParameters() return only the parameter got interceptor or initializer\n      parameterInitializers.set(parameter.index, [origin, intercepted]);\n    }\n\n    return parameterInitializers;\n  }\n\n  private makePropertyInterceptors(\n    target: Function,\n    names: Set<PropertyKey>\n  ): Map<PropertyKey, IInvocation> | undefined {\n    const layers = Reflector(target).findProperties(PropertyFilters.FilterFeatures, AgentFeatures.Interceptor);\n\n    let propertyInterceptors: Map<PropertyKey, IInvocation> | undefined;\n\n    for (const [type, properties] of layers) {\n      if (IsAgent(type.class)) {\n        continue;\n      }\n      for (const [, property] of properties) {\n        const name = property.targetKey;\n        const descriptor = property.descriptor;\n\n        if (!descriptor) {\n          // this is a field\n          // interceptor only works when custom initializer defined for this field\n          if (property.hasInitializer() || property.value.hasInitializer()) {\n            // this interceptor will created in makePropertyInitializers()\n            continue;\n          } else {\n            throw new Error(\n              `Class: ${target.prototype.constructor.name}; Property: ${property.targetKey.toString()}; ` +\n              `Interceptor not work with field property without Initializer`\n            );\n          }\n        }\n\n        // refer to the origin descriptor\n        const newDescriptor = Object.create(descriptor);\n\n        const value = descriptor.value;\n        const getter = descriptor.get;\n        const setter = descriptor.set;\n\n        // find all the attributes\n        let interceptorAttributes = property.getInterceptors();\n\n        if (typeof getter === 'function') {\n          interceptorAttributes = property.getter.getInterceptors().concat(interceptorAttributes);\n          newDescriptor.get = InterceptorFunctionFactory.createFunction(\n            interceptorAttributes,\n            target,\n            getter,\n            property.getter\n          );\n        }\n        if (typeof setter === 'function') {\n          interceptorAttributes = property.setter.getInterceptors().concat(interceptorAttributes);\n          newDescriptor.set = InterceptorFunctionFactory.createFunction(\n            interceptorAttributes,\n            target,\n            setter,\n            property.setter\n          );\n        }\n        if (typeof value === 'function') {\n          // call interceptors on value first\n          // then call interceptors on property\n          interceptorAttributes = property.value.getInterceptors().concat(interceptorAttributes);\n          let parameters: Map<number, [IInvocation, IInvocation]> | undefined;\n          if (property.value.hasParameters()) {\n            parameters = this.compileParameters(value, property.value);\n          }\n          newDescriptor.value = InterceptorFunctionFactory.createFunction(\n            interceptorAttributes,\n            target,\n            value,\n            property.value,\n            parameters\n          );\n        }\n        if (names.has(name)) {\n          throw new Error(\n            `Class: ${target.prototype.constructor.name}; Property: ${property.targetKey.toString()}; ` +\n            `Duplicate interceptor`\n          );\n        } else {\n          names.add(name);\n        }\n        if (!propertyInterceptors) {\n          propertyInterceptors = new Map<PropertyKey, IInvocation>();\n        }\n        propertyInterceptors.set(name, newDescriptor);\n      }\n    }\n\n    return propertyInterceptors;\n  }\n\n  private makePropertyInitializers(\n    target: Function,\n    names: Set<PropertyKey>\n  ): Map<PropertyKey, [IInvocation, IInvocation]> | undefined {\n    const layers = Reflector(target).findProperties(PropertyFilters.FilterFeatures, AgentFeatures.Initializer);\n    let propertyInitializers: Map<PropertyKey, [IInvocation, IInvocation]> | undefined;\n\n    for (const [type, initializers] of layers) {\n      if (IsAgent(type.class)) {\n        continue;\n      }\n      for (const [, property] of initializers) {\n        const name = property.targetKey;\n\n        if (property.descriptor) {\n          // initializer is not for a method / getter / setter\n          throw new Error(\n            `Class: ${target.prototype.constructor.name}; Property: ${property.targetKey.toString()}; ` +\n            `Initializer not work with method / getter / setter`\n          );\n        } else {\n          let initializerAttributes = property.getInitializers();\n          initializerAttributes = property.value.getInitializers().concat(initializerAttributes);\n\n          // one property may have more than one interceptor.\n          // we will call them one by one. passing the result of previous interceptor to the new interceptor\n          const origin = InitializerFactory.createFieldInitializer(target, name, property);\n\n          const initialized = InitializerFactory.chainInitializerAttributes(origin, initializerAttributes);\n\n          // get all interceptors for the initializer\n          let interceptorAttributes = property.getInterceptors();\n          interceptorAttributes = property.value.getInterceptors().concat(interceptorAttributes);\n\n          // apply interceptors\n          const intercepted = InterceptorChainFactory.chainInterceptorAttributes(initialized, interceptorAttributes);\n\n          // InceptionInvocation means at least one interceptor in the attributes\n          // do nothing if no interceptor found\n          if (intercepted instanceof InitializerInvocation || intercepted instanceof InterceptorInvocation) {\n            if (names.has(name)) {\n              throw new Error(\n                `Class: ${target.prototype.constructor.name}; Property: ${property.targetKey.toString()}; ` +\n                `Duplicate initializer`\n              );\n            } else {\n              names.add(name);\n            }\n            if (!propertyInitializers) {\n              propertyInitializers = new Map<PropertyKey, [IInvocation, IInvocation]>();\n            }\n            propertyInitializers.set(name, [origin, intercepted]);\n          }\n        }\n      }\n    }\n\n    return propertyInitializers;\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInvocation } from '../../Core/IInvocation';\nimport { Reflector } from '../../Reflection/Reflector';\nimport { Type } from '../../Reflection/Type';\nimport { ICompiler } from '../ICompiler';\nimport { Arguments } from '../Arguments';\nimport { parameter } from '../Internal/Parameter';\nimport { Resolve } from '../../Internal/Resolve';\nimport { AgentCompiler } from '../AgentCompiler';\n\n/**\n * @ignore\n * @hidden\n */\nexport class ConstructCompiler<C extends Function> {\n  constructor(readonly _newTarget: C, readonly _target: C, readonly _design: any, readonly _params: Arguments) { }\n\n  get target(): Function {\n    return this._target;\n  }\n\n  get agent(): object | undefined {\n    return undefined;\n  }\n\n  get design(): Type {\n    return this._design;\n  }\n\n  get compiler(): ICompiler {\n    const value = Resolve(AgentCompiler);\n    Reflect.defineProperty(this, 'compiler', { value });\n    return value;\n  }\n\n  get compiledParameters(): Map<number, [IInvocation, IInvocation]> {\n    const value = this.compiler.compileParameters(this._target, Reflector(this._target));\n    Reflect.defineProperty(this, 'compiledParameters', { value });\n    return value;\n  }\n\n  get compiledTarget(): any {\n    const value = this.compiler.compile(this._newTarget, this._params);\n    Reflect.defineProperty(this, 'compiledTarget', { value });\n    return value;\n  }\n}\n\n/**\n * @ignore\n * @hidden\n */\nexport class InterceptedConstructInvocation<C extends Function> extends ConstructCompiler<C> implements IInvocation {\n  constructor(_newTarget: C, readonly _args: any, _target: C, _params: Arguments, _design: any) {\n    super(_newTarget, _target, _design, _params);\n  }\n\n  invoke(parameters: ArrayLike<any>) {\n    let args = Array.prototype.slice.call(parameters, 0);\n    for (const [idx, [, interceptor]] of this.compiledParameters.entries()) {\n      args[idx] = interceptor.invoke([parameters[idx], idx, args]);\n    }\n    parameter.set(this._args, args);\n    return Reflect.construct(this._target, args, this.compiledTarget);\n  }\n}\n\n/**\n * @ignore\n * @hidden\n */\nexport class DirectConstructInvocation<C extends Function> extends ConstructCompiler<C> implements IInvocation {\n  constructor(_newTarget: C, readonly _args: any, _target: C, _params: Arguments, _design: any) {\n    super(_newTarget, _target, _design, _params);\n  }\n\n  invoke<T>(parameters: ArrayLike<any>): T {\n    if (Array.isArray(parameters)) { parameter.set(this._args, parameters); }\n    return Reflect.construct(this._target, parameters, this.compiledTarget);\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { DirectConstructInvocation, InterceptedConstructInvocation } from './Invocation/ConstructInvocation';\nimport { Arguments } from './Arguments';\nimport { Reflector } from '../Reflection/Reflector';\nimport { InterceptorChainFactory } from './InterceptorChainFactory';\n\n/**\n * @ignore\n * @hidden\n */\nexport class InterceptorConstructorFactory {\n  static createConstructor<C extends Function>(newTarget: C, args: ArrayLike<any>, target: C, params: Arguments) {\n    // search all attributes on this class constructor\n    const design = Reflector(target);\n    let invocation;\n    if (design.hasParameters()) {\n      invocation = new InterceptedConstructInvocation(newTarget, args, target, params, design);\n    } else {\n      invocation = new DirectConstructInvocation(newTarget, args, target, params, design);\n    }\n    const interceptors = design.getInterceptors();\n    return InterceptorChainFactory.chainInterceptorAttributes(invocation, interceptors);\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nexport const agentClass = 'Agent';\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { InterceptorConstructorFactory } from '../InterceptorConstructorFactory';\nimport { Arguments } from '../Arguments';\nimport { parameter } from '../Internal/Parameter';\nimport { agentClass } from '../Internal/Constants';\nimport { IInvocation } from '../../Core/IInvocation';\nimport { IInitializer } from '../../Core/IInitializer';\nimport { Reflector } from '../../Reflection/Reflector';\n\nexport class LazyClassInitializer implements IInitializer {\n  constructor() {\n    const constructors = new WeakMap<any, IInvocation>();\n    function construct<C extends Function>(newTarget: C, args: ArrayLike<any>, target: C, params: Arguments) {\n      let ctor = constructors.get(newTarget);\n      if (!ctor) {\n        ctor = InterceptorConstructorFactory.createConstructor(newTarget, args, target, params);\n        constructors.set(newTarget, ctor);\n      }\n      return ctor.invoke(args);\n    }\n    // use string to avoid runtime error by compressor or obfuscater\n    Reflect.set(this.target, 'construct', construct);\n  }\n  // isParametersAvailable() make sure this is the only way need to add parameter interceptor\n  readonly target = function (args: ArrayLike<any>): ArrayLike<any> {\n    return parameter.has(args) ? parameter.get(args)! : args;\n  };\n\n  public initialize(target: IInvocation, parameters: ArrayLike<any>): any {\n    const name = target.target.name || agentClass;\n    const type = Reflector(target.target);\n    const code =\n      `class ${name}$ extends ${name}{\\n` +\n      `  constructor(){return Reflect.construct(${name}$,arguments,${name},()=>Reflect(arguments))}\\n` +\n      '}';\n    // const code = `class ${name}$ extends ${name}{constructor(){\n    // return Reflect.construct(new.target,arguments,${name},()=>Reflect(arguments))}}`;\n    return target.invoke([name, code, this.target, type]);\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IInitializerAttribute } from '../Core/IAttribute';\nimport { IInitializer } from '../Core/IInitializer';\nimport { LazyClassInitializer } from './Initializer/LazyClassInitializer';\nimport { Resolve } from '../Internal/Resolve';\n\n/**\n * This attribute is for agent / domain management\n */\nexport class AgentAttribute implements IInitializerAttribute {\n  beforeDecorate(target: Function): boolean {\n    return true;\n  }\n\n  get initializer(): IInitializer {\n    return Resolve(LazyClassInitializer);\n  }\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { Reflector } from './Reflection/Reflector';\nimport { decorateAgent } from './Decorator/decorateAgent';\nimport { AgentAttribute } from './Compiler/AgentAttribute';\nimport { IAttribute } from './Core/IAttribute';\nimport { Resolve } from './Internal/Resolve';\nimport { Constructor } from './Compiler/Constructor';\nimport { CanDecorate } from './Compiler/Internal/Utils';\nimport { CreateAgentInvocation } from './Compiler/CreateAgentInvocation';\n\n/* istanbul ignore next */\nlet polyfill: any = function () {\n  /* tslint:disable */\n  return function () { };\n  /* tslint:enable */\n};\n\n/* istanbul ignore next */\nif (Reflect['metadata'] && !Reflect['metadata']['af']) {\n  // because we know this is polyfill that's why we do current implementation\n  // if one day the browser implemented Reflect.metadata. We will reflector all\n  // metadata data related code to have better performance.\n  polyfill = Reflect['metadata'];\n}\n\n// ===========================================\n// ES6 and after\n// ===========================================\nfunction metadata(this: any, target: Function | Object, property?: string | symbol, descriptor?: PropertyDescriptor) {\n  if (property) {\n    Reflector(target)\n      .property(property, descriptor)\n      .addMetadata(this.key, this.value);\n  } else {\n    Reflector(target).addMetadata(this.key, this.value);\n  }\n  this.polyfill(target, property, descriptor);\n}\nReflect['metadata'] = function (key: string, value: any) {\n  return metadata.bind({ key, value, polyfill: polyfill.apply(this, [key, value]) });\n};\nReflect['metadata']['af'] = true;\n/**\n * Define an agent\n */\nexport function agent(attributes?: IAttribute[]) {\n  return decorateAgent(Resolve(AgentAttribute), attributes);\n}\n\n/**\n * Upgrade a class with @decorators into agent (add support for Interceptor and Initializer)\n */\nexport function Agent<T>(target: Constructor<T>, options?: AgentAttribute): Constructor<T> {\n  // the attributes to initialize agent constructor\n  // current only support only one initializer, multiple interceptors\n  if (!options) {\n    options = Resolve(AgentAttribute);\n  }\n  if (CanDecorate(options, target)) {\n    return CreateAgentInvocation(target, options);\n  }\n  return target;\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IAttribute } from '../Core/IAttribute';\nimport { Reflector } from '../Reflection/Reflector';\nimport { CanDecorate } from '../Compiler/Internal/Utils';\n\n/**\n * Decorate class method parameter\n */\nexport function decorateParameter(attribute: IAttribute): ParameterDecorator {\n  return (target: Object, propertyKey: string | symbol, parameterIndex: number): void => {\n    if (CanDecorate(attribute, target, propertyKey, parameterIndex)) {\n      if (propertyKey == null) {\n        // this is for constructor\n        Reflector(target)\n          .parameter(parameterIndex)\n          .addAttribute(attribute);\n      } else {\n        // parameter for methods, only method have parameters\n        Reflector(target)\n          .property(propertyKey)\n          .value.parameter(parameterIndex)\n          .addAttribute(attribute);\n      }\n    }\n  };\n}\n","/* Copyright 2016 Ling Zhang\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport { IAttribute } from '../Core/IAttribute';\nimport { Reflector } from '../Reflection/Reflector';\nimport { CanDecorate } from '../Compiler/Internal/Utils';\n\n/**\n * Decorate class with attribute\n */\nexport function decorateClass(attribute: IAttribute): ClassDecorator {\n  // upgrade prototype\n  return (target: Function): void => {\n    if (CanDecorate(attribute, target)) {\n      Reflector(target).addAttribute(attribute);\n    }\n    return void 0;\n  };\n}\n\n/**\n * Decorate class properties (field, getter, setter and methods)\n */\nexport function decorateClassMember(attribute: IAttribute) {\n  return (target: Object, propertyKey: string | symbol, descriptor?: PropertyDescriptor): void => {\n    if (CanDecorate(attribute, target, propertyKey, descriptor)) {\n      Reflector(target)\n        .property(propertyKey, descriptor)\n        .addAttribute(attribute);\n    }\n  };\n}\n\n/**\n * Decorate class method\n */\nexport function decorateClassMethod(attribute: IAttribute): MethodDecorator {\n  return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor): void => {\n    if (CanDecorate(attribute, target, propertyKey, descriptor)) {\n      Reflector(target)\n        .property(propertyKey, descriptor)\n        .value.addAttribute(attribute);\n    }\n  };\n}\n\n/**\n * Decorate class field\n */\nexport function decorateClassField(attribute: IAttribute): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol, descriptor?: PropertyDescriptor): void => {\n    // TypeScript is not smart enough to identify the PropertyDescriptor on method\n    if (descriptor) {\n      throw new TypeError(\n        `${Reflect.getPrototypeOf(attribute).constructor.name} can only decorate on class field property`\n      );\n    }\n    if (CanDecorate(attribute, target, propertyKey)) {\n      Reflector(target)\n        .property(propertyKey)\n        .value.addAttribute(attribute);\n    }\n  };\n}\n"],"names":["CanDecorate","attr","target","targetKey","descriptor","beforeDecorate","HasInterceptor","attribute","Reflect","has","HasInitializer","Member","[object Object]","parent","this","Map","_attributes","push","_hasInterceptor","_hasInitializer","type","filter","a","slice","some","length","_metadata","size","key","get","value","set","Parameter","index","super","getMetadata","Method","maxParameters","_parameters","Array","x","isNaN","TypeError","parameter","_cachedParameters","p","hasInitializer","hasInterceptor","parameters","paramtypes","returntype","AgentFeatures","Property","_key","_descriptor","maxFunctionParameters","defineProperty","setter","getter","_hasInitializers","_hasInterceptors","hasParameters","features","Metadata","hasMetadata","Initializer","hasInitializers","Interceptor","hasInterceptors","Altered","addMetadata","types","idx","PropertyFilters","property","filterCriteria","hasAttribute","Error","hasFeatures","GetWeakMap","Function","Agents","Types","IsAgent","agent","Type","prototype","constructor","_prototype","_properties","found","class","_prototypes","unshift","of","Object","getPrototypeOf","getOwnPropertyDescriptor","values","feature","FilterFeatures","properties","entries","layers","findOwnProperties","Reflector","SyntaxError","ctor","proto","Target","InitializerInvocation","_invocation","_initializer","design","initialize","InterceptorInvocation","_interceptor","intercept","AgentInvocation","_target","code","args","construct","CreateAgentInvocation","invocation","initializer","interceptor","newTarget","invoke","arguments","decorateAgent","options","attributes","addAttribute","WeakMap","Resolve","params","undefined","Compiler","generated","fields","origin","configurable","enumerable","writable","FieldInvocation","_propertyKey","_design","_newAgent","ParameterInvocation","InitializerFactory","propertyKey","InterceptorChainFactory","DirectMethodInvocation","method","apply","InterceptedMethodInvocation","call","InterceptorFunctionFactory","factory","name","chain","chainInterceptorAttributes","AgentCompiler","names","Set","initializers","interceptors","compiled","makePropertyInitializers","makePropertyInterceptors","compiler","defineFields","defineProperties","compile","parameterInitializers","initializerAttributes","getInitializers","createParameterInitializer","initialized","chainInitializerAttributes","interceptorAttributes","getInterceptors","intercepted","findProperties","propertyInterceptors","toString","newDescriptor","create","concat","createFunction","compileParameters","add","propertyInitializers","createFieldInitializer","ConstructCompiler","_newTarget","_params","compiledParameters","compiledTarget","InterceptedConstructInvocation","_args","DirectConstructInvocation","isArray","InterceptorConstructorFactory","agentClass","LazyClassInitializer","constructors","createConstructor","AgentAttribute","polyfill","bind","allows","descriptorType","ConstructorParameter","Constructor","MethodParameter","Field","Getter","Setter","parameterIndex"],"mappings":"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"}