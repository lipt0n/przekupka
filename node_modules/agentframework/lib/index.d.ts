export interface IInvocation {
	/**
	 *
	 */
	readonly design: any;
	/**
	 * The class
	 */
	readonly target: Function;
	/**
	 * The instance
	 */
	readonly agent: object | undefined;
	/**
	 * The next function
	 *
	 * @param parameters
	 */
	invoke<T>(parameters: ArrayLike<any>): T;
}
/**
 * Initialize a field
 */
export interface IInitializer {
	initialize(target: IInvocation, parameters: ArrayLike<any>): any;
}
/**
 * Intercept an method call
 */
export interface IInterceptor {
	intercept(target: IInvocation, parameters: ArrayLike<any>): any;
}
export interface IAttribute {
	/**
	 * Get initializer for current target
	 */
	readonly initializer?: IInitializer;
	/**
	 * Get interceptor for current target
	 */
	readonly interceptor?: IInterceptor;
	/**
	 * Before decoration hook. Return false to stop decorate this attribute to a class
	 *
	 * @param {Object | Function} target
	 * @param {string | Symbol} key
	 * @param {PropertyDescriptor} descriptor
	 * @returns {boolean}
	 */
	beforeDecorate(target: Object | Function, key?: string | symbol, descriptor?: PropertyDescriptor | number): boolean;
}
export interface IInterceptorAttribute extends IAttribute {
	readonly interceptor: IInterceptor;
}
export interface IInitializerAttribute extends IAttribute {
	readonly initializer: IInitializer;
}
export interface Constructor<T extends Object = Object> {
	prototype: T;
	new (...parameters: Array<any>): T;
}
export declare enum Target {
	Constructor = 1,
	ConstructorParameter = 2,
	Field = 4,
	Method = 8,
	MethodParameter = 16,
	Getter = 32,
	Setter = 64
}
/**
 * This is universal decorator for all supported target
 */
export interface UniversalDecorator {
	(target: Function | Object, targetKey?: string | symbol, descriptor?: number | PropertyDescriptor): any;
}
/**
 * Decorate attribute to the target
 */
export declare function decorate(attribute: IAttribute, allows: Target): UniversalDecorator;
/**
 * This attribute is for agent / domain management
 */
export declare class AgentAttribute implements IInitializerAttribute {
	beforeDecorate(target: Function): boolean;
	readonly initializer: IInitializer;
}
/**
 * Decorate an agent with customized initializer, interceptors and attributes
 *
 * @param {AgentAttribute} options
 * @param {IAttribute[]} attributes
 * @returns {ClassDecorator}
 */
export declare function decorateAgent(options: AgentAttribute, attributes?: IAttribute[]): ClassDecorator;
/**
 * Decorate class method parameter
 */
export declare function decorateParameter(attribute: IAttribute): ParameterDecorator;
/**
 * Decorate class with attribute
 */
export declare function decorateClass(attribute: IAttribute): ClassDecorator;
/**
 * Decorate class properties (field, getter, setter and methods)
 */
export declare function decorateClassMember(attribute: IAttribute): (target: Object, propertyKey: string | symbol, descriptor?: PropertyDescriptor | undefined) => void;
/**
 * Decorate class method
 */
export declare function decorateClassMethod(attribute: IAttribute): MethodDecorator;
/**
 * Decorate class field
 */
export declare function decorateClassField(attribute: IAttribute): PropertyDecorator;
/**
 * Access and store attribute and metadata for reflection
 */
export declare abstract class Member<P> {
	protected readonly parent: P;
	private _attributes;
	private _metadata;
	private _hasInterceptor;
	private _hasInitializer;
	protected constructor(parent: P);
	/**
	 * Add an attribute
	 * @param {IAttribute} attribute
	 */
	addAttribute(attribute: IAttribute): void;
	/**
	 * Return an array of attributes which is instance of giving type
	 * @returns {IAttribute[]}
	 */
	getAttributes<U1 extends IAttribute>(type?: Constructor<U1>): U1[];
	/**
	 * Return true if this type contains a giving attribute, otherwise false.
	 * @param type
	 * @returns {boolean}
	 */
	hasAttribute<U2 extends IAttribute>(type?: Constructor<U2>): boolean;
	/**
	 * Return an array of all the attributes which provide getInterceptor method
	 * @returns {IInterceptorAttribute[]}
	 */
	getInterceptors(): IInterceptorAttribute[];
	/**
	 * Return an array of all the attributes which provide getInitializer method
	 * @returns {IInitializerAttribute[]}
	 */
	getInitializers(): IInitializerAttribute[];
	/**
	 * Return true if any of the attribute provide getInterceptor method
	 * @returns {boolean}
	 */
	hasInterceptor(): boolean;
	/**
	 * Return true if any of the attribute provide getInitializer method
	 *
	 * @returns {boolean}
	 */
	hasInitializer(): boolean;
	/**
	 * Return true if have metadata
	 */
	hasMetadata(): boolean;
	/**
	 * Read the metadata generated by tsc
	 *
	 * @param key
	 */
	getMetadata(key: string): any | undefined;
	/**
	 * Add the metadata generated by tsc
	 *
	 * @param {string} key
	 * @param value
	 */
	addMetadata(key: string, value: any): void;
}
/**
 * Parameter
 */
export declare class Parameter<P extends Member<any>> extends Member<P> {
	readonly index: number;
	constructor(parent: P, index: number);
	readonly type: any;
}
/**
 * Method
 */
export declare class Method<P> extends Member<P> {
	maxParameters: number;
	private readonly _parameters;
	private _cachedParameters;
	constructor(parent: P, maxParameters: number);
	parameter(index: number): Parameter<Method<P>>;
	parameters(): Array<Parameter<Method<P>>>;
	hasParameters(): boolean;
	readonly paramtypes: Array<any>;
	readonly returntype: any;
}
export declare enum AgentFeatures {
	/**
	 * has nothing
	 */
	None = 0,
	/**
	 * has metadata
	 */
	Metadata = 1,
	/**
	 * has initializer
	 */
	Initializer = 2,
	/**
	 * has interceptor
	 */
	Interceptor = 4,
	/**
	 * has initializer or interceptor
	 */
	Altered = 6
}
/**
 * Property
 */
export declare class Property extends Member<Type> {
	private _key;
	private _descriptor?;
	private _hasInitializers;
	private _hasInterceptors;
	constructor(parent: Type, _key: PropertyKey, _descriptor?: PropertyDescriptor | undefined);
	readonly value: Method<Property>;
	readonly setter: Method<Property>;
	readonly getter: Method<Property>;
	hasInitializers(): boolean;
	hasInterceptors(): boolean;
	hasFeatures(features: AgentFeatures): boolean;
	readonly type: any;
	readonly paramtypes: Array<any>;
	readonly returntype: any;
	readonly targetKey: PropertyKey;
	readonly descriptor: PropertyDescriptor | undefined;
	/**
	 * Add the metadata generated by tsc
	 * @param {string} key
	 * @param value
	 */
	addMetadata(key: string, value: any): void;
}
/**
 * Represents a callback function that is used to filter a list of behavior represented in a map of Behavior objects.
 */
export interface PropertyFilter {
	/**
	 * @param {Property} value The Behavior object to which the filter is applied.
	 * @param filterCriteria An arbitrary object used to filter the list.
	 * @returns {boolean} `true` to include the behavior in the filtered list; otherwise false.
	 */
	(value: Property, filterCriteria?: any): boolean;
}
export declare class PropertyFilters {
	static FilterAttribute<T extends IAttribute>(property: Property, filterCriteria?: Constructor<T>): boolean;
	static FilterFeatures(property: Property, filterCriteria?: AgentFeatures): boolean;
}
/**
 * Reflection information for user class
 *
 * A class is a Function. So Class extends from Method
 */
export declare class Type extends Method<null> {
	private readonly _prototype;
	private readonly _properties;
	private _prototypes;
	constructor(prototype: Object);
	static of(prototype: Object): Type;
	/**
	 * Return the constructor of reflecting class
	 */
	readonly class: Constructor<any>;
	/**
	 * Return the prototype of reflecting class
	 */
	readonly prototype: object;
	/**
	 * Return prototype array for current type - deep first [base of base, base, this]
	 */
	types(): Array<Type>;
	/**
	 * Add the metadata
	 */
	addMetadata(key: string, value: any): void;
	/**
	 * Return property info for specified property key
	 *
	 * @param {string | Symbol | number} key
	 * @param {PropertyDescriptor} descriptor
	 * @returns {Property}
	 */
	property(key: PropertyKey, descriptor?: PropertyDescriptor): Property;
	/**
	 * Return all properties
	 *
	 * @returns {IterableIterator<Property>}
	 */
	properties(): IterableIterator<Property>;
	/**
	 * Return true if contains the giving agent feature
	 */
	hasFeatures(feature: AgentFeatures): boolean;
	/**
	 * Returns a filtered array of Property objects of this prototype.
	 *
	 * @param {PropertyFilter} filter
	 * @param filterCriteria
	 * @returns {Property[]}
	 */
	findOwnProperties(filter: PropertyFilter, filterCriteria?: any): Map<PropertyKey, Property>;
	/**
	 * Returns a filtered array of Property objects for all prototype in prototype chain.
	 *
	 * @param {PropertyFilter} filter
	 * @param filterCriteria
	 * @returns {Property[]}
	 */
	findProperties(filter: PropertyFilter, filterCriteria?: any): Array<[Type, Map<PropertyKey, Property>]>;
}
/**
 * Define an agent
 */
export declare function agent(attributes?: IAttribute[]): ClassDecorator;
/**
 * Upgrade a class with @decorators into agent (add support for Interceptor and Initializer)
 */
export declare function Agent<T>(target: Constructor<T>, options?: AgentAttribute): Constructor<T>;
/**
 * Reflector is the interface to access type data from class or class instance or class prototype
 */
export declare function Reflector(target: Function | Object): Type;
export declare function IsAgent(agent: Function): boolean;
export declare function GetType<T>(agent: Function): Constructor<T> | undefined;